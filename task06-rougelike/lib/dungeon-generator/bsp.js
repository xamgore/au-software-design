/*
 Basic BSP dungeon generation
 from http://www.roguebasin.com/index.php?title=Basic_BSP_Dungeon_generation

 1.  start with rectangular dungeon filled with wall cells

 2.  split recursively until each sub-dungeon has approximately the size of a room.
 a.  choose a random direction (hSplit or vSplit)

 b.  choose a random position (x or y)
 make sure split position is not too close to border, so a min-sized room can fit.
 different rules on splitting position can result in more homogeneous (position 0.45 - 0.55)
 or heterogeneous (0.1 - 0.9) dungeons.

 c.  split into two sub-dungeons.
 one rect goes in, and if successful, two rects come out

 3.  repeat until the lowest sub-dungeons have approximately the size of partitions wanted,
 or until possibly other conditions are met (such as max iterations for instance)
 */
Game.BSPdungeon = function (width, height, tileset, options) {
  options = options || {}

  if (!tileset) {
    tileset = Game.Tilesets.cave
  }
  this.tileset = tileset

  this.minRoomSize = options['minRoomSize'] || 3
  this.minRoomWidth = options['minRoomWidth'] || this.minRoomSize
  this.minRoomHeight = options['minRoomHeight'] || this.minRoomSize
  this.maxRoomSize = options['maxRoomSize'] || 10
  this.maxRoomWidth = options['maxRoomWidth'] || this.maxRoomSize
  this.maxRoomHeight = options['maxRoomHeight'] || this.maxRoomSize
  this.maxIterations = options['maxIterations'] || 5

  this.largerRoomChance = options['largerRoomChance'] || 0.6
  /*  splitConstraint = (option; +/- 0.5, to constrain splitPos)
   (example; if option = 0.05, splitPos would be limited to 0.45 - 0.55 of avail width/height)
   (if not passed in, we can choose random value from 0 - 0.5: Math.random() * 0.5);
   */
  this.splitConstraint = options['splitConstraint'] || Math.random() * 0.5

  /* partitions array to store the final available areas generated by the trySplit method */
  this.partitions = []

  /* 'master' roomRect to start with */
  this.masterRoom = new Game.Geometry.roomRect(0, 0, width - 1, height - 1)
  this.masterWidth = width
  this.masterHeight = height

  this.rooms = []
  this.corridors = []
}

Game.BSPdungeon.prototype.generate = function () {
  // make the partitions
  this.trySplit(this.masterRoom, 0)      // populates this.partitions[]

  // make the rooms within partitions
  this.createRooms(this.largerRoomChance)    // populates this.rooms[]

  // make a 'graph' from the rooms
  var adjacencyList = this.makeRoomsGraph(this.rooms)
  // creates & populates this.roomsGraph[]
  // roomsGraph is an array of connections: {start:{room, x,y}, end:{room, x,y}, dir, distance}
  // also returns adjacencyList: a hashtable of roomIndex: neighborsList[]

  // use the graph with some BFS logic to figure out corridor placements
  this.placeCorridors(adjacencyList, randomInt(0, this.rooms.length - 1))
  // this populates an internal roomConnections table
  // it calls this.makeCorridor, which populates this.corridors
}

Game.BSPdungeon.prototype.trySplit = function (parentRect, currentIteration) {
  // in case we do something dumb and forget to pass in '0' on the first call
  if (currentIteration === null || currentIteration === undefined) {
    currentIteration = 0
  }

  var cantSplit = false      // to be changed to true if any "break" condition is met

  // cache parentWidth, parentHeight
  var parentWidth = parentRect.getWidth()
  var parentHeight = parentRect.getHeight()

  // if the room we are trying to split is small enough (within the max size limits)
  // and if we've already done enough splits, break
  if (parentWidth < this.maxRoomWidth && parentHeight < this.maxRoomHeight &&
    currentIteration >= this.maxIterations) {
    cantSplit = true

    // if the room we are trying to split is smaller in both directions than min size, break
  } else if (parentWidth <= this.minRoomWidth && parentHeight <= this.minRoomHeight) {
    cantSplit = true
  }

  if (cantSplit) {
    // parent is a leaf node, add to the partitions array
    this.partitions.push(parentRect)

  } else {
    // choose a random axis to try to split along
    // var splitAxis = randomInt(0, 1);    // horizontal = 1, vertical = 0.

    // instead of completely random, we should compare the parent width to the parent height,
    // and favor one axis over the other.
    var whDiff = parentWidth - parentHeight        // if (+), width is greater; if (-), height is greater
    // simple solution:
    // var splitAxis = (whDiff > 0) ? 0 : 1;        // where 0 = vertical, 1 = horizontal.
    // however, that would always favor a vertical split in cases where width == height.
    //
    // we could try:
    // var splitAxis = (whDiff > 0) ? 0 : ( (whDiff < 0) ? 1 : randomInt(0, 1) );
    //
    // however, the above solution will always favor the 'ideal' split axis,
    // which will result in very 'homogeneous' .
    // We could take the 'homogeneity/heterogeneity' factor into account using the splitConstraint
    // (which is what it's designed to do).
    //
    // We could find the splitAxis as above, and then have a chance to 'flip' it, based on splitConstraint.
    // Since splitConstraint is typically from 0.05 (more homogeneous) to 0.45 (more heterogeneous),
    // that seems like the perfect parameter for what we are trying to do here. :)

    var splitAxis = (whDiff > 0) ? 0 : ((whDiff < 0) ? 1 : randomInt(0, 1))
    if (ROT.RNG.getUniform() < this.splitConstraint) {
      splitAxis = !splitAxis
    }

    var checkAltAxis = false           // we can check the other axis if the original one fails

    var xMin, yMin, xMax, yMax
    var minSplitPos, maxSplitPos
    var constraintMin, constraintMax
    // we want to run this at most twice: once for each axis.
    // if we can't make a good split on the first run, we set checkAltAxis to true;
    // if we can't make a good split on the second run, we also set cantSplit to true.
    while (!(checkAltAxis && cantSplit)) {
      // see if this is a repeat check on the other axis
      if (checkAltAxis) {
        splitAxis = !splitAxis
      }

      // choose a random split position (x or y)
      // make sure split position isn't too close to parent border, so a min-sized room can still fit
      xMin = parentRect.topLeftX
      yMin = parentRect.topLeftY
      xMax = parentRect.bottomRightX
      yMax = parentRect.bottomRightY

      // these are originally defined only based on the available geometry
      minSplitPos = splitAxis ? (yMin + this.minRoomHeight) : (xMin + this.minRoomWidth)
      maxSplitPos = splitAxis ? (yMax - this.minRoomHeight) : (xMax - this.minRoomWidth)

      // now we want to compare these to splitConstraint and choose the tightest range
      // splitConstraint is applied as follows:
      // constraintMin (horizontal):    (0.5 - splitConstraint) * parentHeight
      // constraintMin (vertical):      (0.5 - splitConstraint) * parentWidth
      // constraintMax (horizontal):    (0.5 + splitConstraint) * parentHeight
      // constraintMax (vertical):      (0.5 + splitConstraint) * parentWidth
      constraintMin = Math.floor((0.5 - this.splitConstraint) * (splitAxis ? parentHeight : parentWidth))
      constraintMax = Math.ceil((0.5 + this.splitConstraint) * (splitAxis ? parentHeight : parentWidth))

      // if the constraint (min, max) is a tighter range than the geometry-based (min, max) then use that
      if (constraintMin > minSplitPos && constraintMax < maxSplitPos) {
        minSplitPos = constraintMin
        maxSplitPos = constraintMax
      }

      // if minSplitPos or maxSplitPos is out of bounds, see if checkAltAxis is also true
      // if so, then we've run both axes already, so set cantSplit true, and break.
      if (minSplitPos >= (splitAxis ? yMax : xMax) ||
        maxSplitPos <= (splitAxis ? yMin : xMin) ||
        minSplitPos > maxSplitPos) {
        if (!checkAltAxis) {
          checkAltAxis = true
        } else {
          cantSplit = true
        }
      } else {
        break
      }
    }

    if (cantSplit) {               // no reason to run the rest of it if we already know we can't split
      // parent is a leaf node, add to the partitions array
      this.partitions.push(parentRect)

    } else {

      var splitPos = randomInt(minSplitPos, maxSplitPos)
      // note that neither childRect will include the row/col (depending on splitAxis) of the splitPos
      // in other words, childRect will be a virtual "room" carved out of a solid filled dungeon
      // and subject to further splitting

      // var childATopLeftX = xMin;
      // var childATopLeftY = yMin;
      var childABottomRightX = splitAxis ? xMax : (splitPos - 1)
      var childABottomRightY = splitAxis ? (splitPos - 1) : yMax

      var childRectA = new Game.Geometry.roomRect(xMin, yMin, childABottomRightX, childABottomRightY)

      var childBTopLeftX = splitAxis ? xMin : (splitPos + 1)
      var childBTopLeftY = splitAxis ? (splitPos + 1) : yMin
      // var childBBottomRightX = xMax;
      // var childBBottomRightY = yMax;

      var childRectB = new Game.Geometry.roomRect(childBTopLeftX, childBTopLeftY, xMax, yMax)

      this.trySplit(childRectA, currentIteration + 1)
      this.trySplit(childRectB, currentIteration + 1)

    }
  }
}

/*
 4.  create room with random size in each leaf of the tree (each sub-dungeon).
 room must be contained within the corresponding sub-dungeon
 the BSP dungeon tree algorithm prevents overlapping partitions.
 */
Game.BSPdungeon.prototype.createRooms = function (largerRoomChance) {
  if (this.partitions === []) {
    return
  }

  if (this.rooms === null || this.rooms === undefined) {
    this.rooms = []
  }

  largerRoomChance = largerRoomChance || 0.5

  // loop through the partitions array
  for (var p = 0; p < this.partitions.length; p++) {
    var partition = this.partitions[p]
    // for each partition, pick a random (x,y) for room (topLeftX, topLeftY)
    // making sure that minRoomSize can still fit

    // set the boundaries first
    var minRoomTopLeftX = partition.topLeftX
    var maxRoomTopLeftX = partition.topLeftX + (partition.getWidth() - this.minRoomWidth)

    var minRoomTopLeftY = partition.topLeftY
    var maxRoomTopLeftY = partition.topLeftY + (partition.getHeight() - this.minRoomHeight)

    // now pick a top left from the established boundaries
    // start with the min value, and roll vs largerRoomChance
    // if roll > largerRoomChance, test min + 1
    // and so on, until we hit the max value
    // this should favor larger room sizes better than a simple random(min, max).

    // var roomTopLeftX = randomInt(minRoomTopLeftX, maxRoomTopLeftX);
    // var roomTopLeftY = randomInt(minRoomTopLeftY, maxRoomTopLeftY);

    var x, y, roll

    var roomTopLeftX
    for (x = minRoomTopLeftX; x <= maxRoomTopLeftX; x++) {
      roll = ROT.RNG.getUniform()
      if (roll < largerRoomChance) {
        roomTopLeftX = x
        break
      } else {
        // make an exception if we're already at the end with no break yet
        if (x == maxRoomTopLeftX) {
          roomTopLeftX = x
          break
        }
      }
    }

    var roomTopLeftY
    for (y = minRoomTopLeftY; y <= maxRoomTopLeftY; y++) {
      roll = ROT.RNG.getUniform()
      if (roll < largerRoomChance) {
        roomTopLeftY = y
        break
      } else {
        // make an exception if we're already at the end with no break yet
        if (y == maxRoomTopLeftY) {
          roomTopLeftY = y
          break
        }
      }
    }

    // after getting a random (topLeftX, topLeftY) for our room (from the above limits)
    // get a random room size, i.e., a random (x,y) for room (bottomRightX, bottomRightY)

    var maxRoomBottomRightX = partition.bottomRightX
    var minRoomBottomRightX = roomTopLeftX + (this.minRoomWidth - 1)

    var maxRoomBottomRightY = partition.bottomRightY
    var minRoomBottomRightY = roomTopLeftY + (this.minRoomHeight - 1)

    // same as before, pick a bottom right from the established boundaries
    // start with the max (to favor larger rooms) and roll
    // if roll fails, test max - 1, and so on, until we hit min

    // var roomBottomRightX = randomInt(minRoomBottomRightX, maxRoomBottomRightX);
    // var roomBottomRightY = randomInt(minRoomBottomRightY, maxRoomBottomRightY);

    var roomBottomRightX
    for (x = maxRoomBottomRightX; x >= minRoomBottomRightX; x--) {
      roll = ROT.RNG.getUniform()
      if (roll < largerRoomChance) {
        roomBottomRightX = x
        break
      } else {
        // make an exception if we're already at the end with no break yet
        if (x == minRoomBottomRightX) {
          roomBottomRightX = x
          break
        }
      }
    }

    var roomBottomRightY
    for (y = maxRoomBottomRightY; y >= minRoomBottomRightY; y--) {
      roll = ROT.RNG.getUniform()
      if (roll < largerRoomChance) {
        roomBottomRightY = y
        break
      } else {
        // make an exception if we're already at the end with no break yet
        if (y == minRoomBottomRightY) {
          roomBottomRightY = y
          break
        }
      }
    }

    var room = new Game.Geometry.roomRect(roomTopLeftX, roomTopLeftY, roomBottomRightX, roomBottomRightY)
    this.rooms.push(room)
  }
}

Game.BSPdungeon.prototype.createGridArray = function (arrayToUse) {
  // parameter determines which array to use, this.rooms or this.partitions
  if (!arrayToUse || arrayToUse == []) {
    return []
  }
  if (!(arrayToUse == this.rooms || arrayToUse == this.partitions)) {
    return []
  }

  // generate a new grid using masterWidth and masterHeight
  // filling all tiles with wallTile
  var grid = new Array(this.masterWidth)
  var x, y
  for (x = 0; x < this.masterWidth; x++) {
    grid[x] = new Array(this.masterHeight)
    for (y = 0; y < this.masterHeight; y++) {
      grid[x][y] = 1 //this.tileset.wall;
    }
  }

  // loop through the chosen array.
  var p, pX, pY, len = arrayToUse.length
  for (p = 0; p < len; p++) {
    // for each room/partition in chosen array, loop through the tiles
    for (pX = arrayToUse[p].topLeftX; pX <= arrayToUse[p].bottomRightX; pX++) {
      for (pY = arrayToUse[p].topLeftY; pY <= arrayToUse[p].bottomRightY; pY++) {
        grid[pX][pY] = 0 //this.tileset.floor;
      }
    }
  }

  // if it was the rooms array, and if we already have a corridors array,
  // apply that as well.
  if (arrayToUse == this.rooms && this.corridors && this.corridors !== []) {
    // loop through corridors array
    var c, corr, clen = this.corridors.length
    for (c = 0; c < clen; c++) {
      corr = this.corridors[c]
      grid[corr.x][corr.y] = 2 //this.tileset.corridor;
    }
  }

  return grid
}

Game.BSPdungeon.prototype.consoleOut = function (grid) {
  if (!grid) {
    return
  }

  // convert array to string for output.
  // (notice we need to break by rows, so the loops are reversed from the usual)
  var gridOut = "\n\r"
  for (var y = 0; y < grid[0].length; y++) {
    for (var x = 0; x < grid.length; x++) {
      if (grid[x][y] === Game.Tile.nullTile) {
        gridOut += "█"
      } else if (grid[x][y] === this.tileset.floor) {
        //gridOut += "░";
        var roomNumber = this.isWithinRoom(x, y)
        if (roomNumber > -1) {
          gridOut += '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.charAt(roomNumber)
        } else {
          gridOut += this.tileset.floor.character
        }

      } else if (grid[x][y] === this.tileset.wall) {
        gridOut += this.tileset.wall.character
      } else if (grid[x][y] === this.tileset.corridor) {
        gridOut += this.tileset.corridor.character
      }
    }
    gridOut += "\n\r"
  }

  console.log(gridOut)
}

Game.BSPdungeon.prototype.makeRoomsGraph = function (rooms) {
  rooms = rooms || this.rooms

  var roomsGraph = []   // array of connections: {start:{room, x,y}, end:{room, x,y}, dir, distance}
  var adjacencyList = {} // hashtable of roomIndex: [neighborsList]
  // loop through directions (0 = N, 1 = E, 2 = S, 3 = W)

  var dir, r, wall, w, startX, startY, current, next, endRoomFound, distance, foundRoomIndex
  var rlen = rooms.length
  for (dir = 0; dir < 4; dir++) {
    // loop through rooms array
    for (r = 0; r < rlen; r++) {

      wall = this.getPerimeters(rooms[r], dir)   // array of {x, y, dir}
      // loop through each element in [wall].
      // scan in dir until another room is found
      // or until map edge is reached.

      var wlen = wall.length
      for (w = 0; w < wlen; w++) {
        startX = wall[w].x
        startY = wall[w].y

        current = wall[w]
        next = current
        endRoomFound = false
        distance = 1
        do {
          next = this.getNextCorridorTile(current)   // returns next if within map bounds
          if (next != current) {      // we can continue in this dir.

            // check if we've hit a room yet
            foundRoomIndex = this.isWithinRoom(next.x, next.y)

            if (foundRoomIndex > -1) {  // we found a room!
              endRoomFound = true
              roomsGraph.push({
                  start: {
                    room: r,
                    x: startX,
                    y: startY
                  },
                  end: {
                    room: foundRoomIndex,
                    x: next.x,
                    y: next.y
                  },
                  dir: dir,
                  distance: distance
                }
              )

              if (adjacencyList[r] === null || adjacencyList[r] === undefined) {
                adjacencyList[r] = []
              }
              // uncomment the next line if we want an equal chance of corridor for
              // neighbors with only 1 possible connection vs many possible connections
              //if (adjacencyList[r].indexOf(foundRoomIndex) === -1) {
              adjacencyList[r].push(foundRoomIndex)
              //}

            } else {    // we didn't find a room
              // keep searching (continue with the do/while loop)
              current = next
              distance++
            }

          } else {    // getNextCorridorTile() returned the same tile; we can't continue in dir.
            break  // break out of while loop and continue with walls loop.
          }
        } while (!endRoomFound)
      }
    }
  }

  this.roomsGraph = roomsGraph

  return adjacencyList
}

Game.BSPdungeon.prototype.placeCorridors = function (graph, start, extraCorridorChance) {
  // essentially, this is a BFS (breadth-first search) graph traversal algorithm.
  // graph should be a hashtable adjacencyList: {roomIndex: [neighborsArray] }
  // start should be a number corresponding to a roomIndex in this.rooms
  extraCorridorChance = extraCorridorChance || 5

  if (this.corridors === null || this.corridors === undefined) {
    this.corridors = []
  }

  var connectedRooms = {}       // stored as {roomIndex, [list of connected rooms]

  var seen = new Array(this.rooms.length)    // stores whether we have visited this roomIndex
  var q = []                                 // roomIndexes with neighbors to investigate
  q.push(start)
  seen[start] = true

  var i, j, n, neighbors, len
  while (q.length !== 0) {

    q = q.randomize()

    i = q.shift()              // get the first roomIndex in the queue
    neighbors = graph[i].randomize()     // get the neighborsArray for this roomIndex
    len = neighbors.length
    // "explore" (add to queue) the neighbors
    for (j = 0; j < len; j++) {
      n = neighbors[j]           // n is a roomIndex of a neighbor of i
      if (!seen[n]) {             // if we haven't been here before
        q.push(n)              // add this roomIndex to the queue
        seen[n] = true         // and mark it seen.

        // make a corridor between n and i
        this.makeCorridor(i, n)
        if (connectedRooms[n] === null || connectedRooms[n] === undefined) {
          connectedRooms[n] = []
        }
        connectedRooms[n].push(i)
        if (connectedRooms[i] === null || connectedRooms[i] === undefined) {
          connectedRooms[i] = []
        }
        connectedRooms[i].push(n)     // so it goes both ways

        // if we HAVE been here before, chance for extra corridor if one doesn't
        // exist between these rooms already
      } else if (ROT.RNG.getPercentage() < extraCorridorChance &&
        connectedRooms[n].indexOf(i) === -1 &&
        connectedRooms[i].indexOf(n) === -1) {
        this.makeCorridor(i, n)
        connectedRooms[n].push(i)
        connectedRooms[i].push(n)     // so it goes both ways
      }
    }
  }
  return connectedRooms
}

Game.BSPdungeon.prototype.makeCorridor = function (startRoomIndex, endRoomIndex) {
  // when this is called, we should already have a this.roomsGraph array
  // of connections: {start: {room, x,y}, end: {room, x,y}, dir, distance}.
  // This lists all possible connections between rooms.

  // loop through roomsGraph array looking for roomsGraph[i].start.room = startRoomIndex,
  // with the corresponding endRoomIndex.
  // there will usually be several entries, one for each possible (x,y) connection.
  // store all possibilities for startRoom => endRoom.
  var connections = []

  var i, len = this.roomsGraph.length
  for (i = 0; i < len; i++) {
    if (this.roomsGraph[i].start.room === startRoomIndex &&
      this.roomsGraph[i].end.room === endRoomIndex) {

      connections.push(this.roomsGraph[i])
    }
  }

  // Now, let's pick a random connection to try.
  connections = connections.randomize()
  var conn = connections.random()

  // start at start (x,y), dig in dir for distance, until end (x,y) is reached.
  // distance is how many tiles we need to dig.

  // actually, we can get both distance and direction from end(x,y) - start(x,y),
  // since for start(x,y) and end(x,y), either one of x or y should stay constant.

  var dX = conn.end.x - conn.start.x     // (+) dig east, (-) dig west
  var dY = conn.end.y - conn.start.y     // (+) dig south, (-) dig north

  var distance = Math.max(Math.abs(dX), Math.abs(dY))

  var d, cX, cY
  for (d = 0; d < distance; d++) {

    // get new coords based on start, distance, and direction.
    // if dX is (+), add d; else, if dX is (-), subtract d.
    cX = conn.start.x + (dX > 0 ? d : (dX < 0 ? (-d) : 0))
    cY = conn.start.y + (dY > 0 ? d : (dY < 0 ? (-d) : 0))

    this.corridors.push({x: cX, y: cY})
  }
}


Game.BSPdungeon.prototype.isWithinRoom = function (x, y) {
  /*
   loop through rooms array comparing x, y.
   if found, return room array index; if not found, return -1.
   */
  var foundIndex = -1

  var p, pY, pX, len = this.rooms.length
  for (p = 0; p < len; p++) {
    for (pY = this.rooms[p].topLeftY; pY <= this.rooms[p].bottomRightY; pY++) {
      for (pX = this.rooms[p].topLeftX; pX <= this.rooms[p].bottomRightX; pX++) {
        if (pX === x && pY === y) {
          foundIndex = p
          break
        }
      }
    }
  }
  return foundIndex
}

Game.BSPdungeon.prototype.getNextCorridorTile = function (currentCorridorTile) {
  /*
   Take the currentCorridorTile {x, y, dir} and try to continue
   the corridor with nextCorridorTile in the same dir.
   */

  var mapWidth = this.masterWidth
  var mapHeight = this.masterHeight
  var inBounds = false

  var nextCorridorTile = {x: currentCorridorTile.x, y: currentCorridorTile.y, dir: currentCorridorTile.dir}

  // switch perimeter.dir:
  if (currentCorridorTile.dir === 0 && currentCorridorTile.y > 0) {            // north
    // X will stay the same; make sure next Y is within bounds.
    nextCorridorTile.y = currentCorridorTile.y - 1
    inBounds = true
  } else if (currentCorridorTile.dir === 1 && currentCorridorTile.x < mapWidth - 1) {     // east
    // Y will stay the same; make sure next X is within bounds.
    nextCorridorTile.x = currentCorridorTile.x + 1
    inBounds = true
  } else if (currentCorridorTile.dir === 2 && currentCorridorTile.y < mapHeight - 1) {     // south
    // X will stay the same; make sure next Y is within bounds.
    nextCorridorTile.y = currentCorridorTile.y + 1
    inBounds = true
  } else if (currentCorridorTile.dir === 3 && currentCorridorTile.x > 0) {     // west
    // Y will stay the same; make sure next X is within bounds.
    nextCorridorTile.x = currentCorridorTile.x - 1
    inBounds = true
  }

  if (inBounds) {
    return nextCorridorTile
  } else {
    return currentCorridorTile
  }

}

Game.BSPdungeon.prototype.getPerimeters = function (room, dir) {
  /*
   get the perimeter walls of each room.
   (tile position and heading)

   for each room: {topLeftX, topLeftY, bottomRightX, bottomRightY},
   the perimeter tiles will be defined by:

   north heading:  (leftmost X, topmost Y - 1) to (rightmost X, topmost Y - 1)
   south heading:  (leftmost X, bottommost Y + 1) to (rightmost X, bottommost Y + 1)
   west heading:   (leftmost X - 1, topmost Y) to (leftmost X - 1, bottommost Y)
   east heading:   (rightmost X + 1, topmost Y) to (rightmost X + 1, bottommost Y)

   north:  {topLeftX, topLeftY - 1, bottomRightX, topLeftY - 1}
   south:  {topLeftX, bottomRightY + 1, bottomRightX, bottomRightY + 1}
   west:   {topLeftX - 1, topLeftY, topLeftX - 1, bottomRightY}
   east:   {bottomRightX + 1, topLeftY, bottomRightX + 1, bottomRightY}

   before storing, we should check to see if it's out of bounds.
   */

  var mapWidth = this.masterWidth
  var mapHeight = this.masterHeight

  var checkAll = false
  if (dir === undefined || dir === null) {
    checkAll = true
  }

  // store the perimeter tiles for each direction
  var perimeters = []        // array of objects: {x, y, dir}

  var pX, pY
  // north heading: Y doesn't change; loop through X
  // make sure Y is within bounds before starting.
  if (room.topLeftY > 0 && (dir === 0 || checkAll)) {
    for (pX = room.topLeftX; pX <= room.bottomRightX; pX++) {
      // make sure X is within bounds before storing.
      if (pX >= 0 && pX < mapWidth) {
        perimeters.push({x: pX, y: room.topLeftY - 1, dir: 0})
      }
    }
  }
  // east heading: X doesn't change; loop through Y
  // make sure X is within bounds before starting.
  if (room.bottomRightX < mapWidth - 1 && (dir === 1 || checkAll)) {
    for (pY = room.topLeftY; pY <= room.bottomRightY; pY++) {
      // make sure Y is within bounds before storing.
      if (pY >= 0 && pY < mapHeight) {
        perimeters.push({x: room.bottomRightX + 1, y: pY, dir: 1})
      }
    }
  }
  // south heading: Y doesn't change; loop through X
  // make sure Y is within bounds before starting.
  if (room.bottomRightY < mapHeight - 1 && (dir === 2 || checkAll)) {
    for (pX = room.topLeftX; pX <= room.bottomRightX; pX++) {
      // make sure X is within bounds before storing.
      if (pX >= 0 && pX < mapWidth) {
        perimeters.push({x: pX, y: room.bottomRightY + 1, dir: 2})
      }
    }
  }
  // west heading: X doesn't change; loop through Y
  // make sure X is within bounds before starting.
  if (room.topLeftX > 0 && (dir === 3 || checkAll)) {
    for (pY = room.topLeftY; pY <= room.bottomRightY; pY++) {
      // make sure Y is within bounds before storing.
      if (pY >= 0 && pY < mapHeight) {
        perimeters.push({x: room.topLeftX - 1, y: pY, dir: 3})
      }
    }
  }

  return perimeters
}

